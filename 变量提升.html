<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>变量提升</title>
</head>
<body>
<h2>
    <pre>
    从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。
    实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。

    JavaScript 在执行任何代码段之前，将函数声明放入内存中的优点之一是，这允许你可以在你的代码中使用一个函数，在声明该函数之前。

    JavaScript 仅提升声明，而不提升初始化！！！


    JS的解析过程分为两个阶段：预编译期(预处理)与执行期！！！

    预编译期JS会对本代码块中的所有声明的变量和函数进行处理（类似与C语言的编译）
    但需要注意的是此时处理函数的只是声明式函数，而且变量也只是进行了声明但未进行初始化以及赋值。
    函数声明在变量声明之前

    在预编译的过程中，会把定义式的函数优先执行，也会把所有var变量创建，默认值为undefined，以提高程序的执行效率。
    变量的赋值是在解释执行阶段完成的，如果在这之前使用变量，它的值会是undefined。变量的申明是在预编译期，初始化是在执行阶段。


    对于同名的变量声明，Javascript采用的是 忽略原则，后声明的会被忽略！
    变量声明和赋值操作可以写在一起，但是只有声明会被提升，提升后变量的值默认为undefined，结果是在赋值操作执行前变量的值必为undefined

    对于同名的函数声明，Javascript采用的是覆盖原则，先声明的会被覆盖！
    因为函数在声明时会指定函数的内容，所以同一作用域下一系列同名函数声明的最终结果是调用时函数的内容和最后一次函数声明相同

    对于同名的函数声明和变量声明，采用的是忽略原则，由于在提升时函数声明会提升到变量声明之前，变量声明一定会被忽略
    </pre>
</h2>
</body>
<script>
	var x = 1;                 // 声明 + 初始化 x
	console.log(x, y);         // '1 undefined'
	var y = 2                  // JavaScript 仅提升声明，而不提升初始化!!!


	/* 采用此种方法创建的函数在函数外层只能使用 fooName 不能使用 fooName1 的函数名。fooName1 的命名只能在创建的函数内部使用 */
	var fooName = function fooName1() {
		console.log(111, fooName1)
	}
	fooName()

	//   console.log(fooName1)


	var foo = function () {
		console.log('wuwu')
	}

	function foo() {
		console.log('haha')
	}


	foo()

	var b = undefined;

	function b() {
		console.log(1)
	};b()


</script>
</html>